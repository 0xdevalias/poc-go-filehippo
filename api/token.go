package api

import (
	"crypto/cipher"
	"crypto/des"
	"encoding/base64"
	"fmt"
	"log"
	"time"
)

//func TripleDesDecrypt(ciphertext, key, iv []byte) ([]byte, error) {
//	block, err := des.NewTripleDESCipher(key)
//	if err != nil {
//		return nil, err
//	}
//
//	blockMode := cipher.NewCBCDecrypter(block, iv[:block.BlockSize()])
//	origData := make([]byte, len(ciphertext))
//	blockMode.CryptBlocks(origData, ciphertext)
//	return origData, nil
//}

func TripleDesEncrypt(plaintext, key, iv []byte) ([]byte, error) {
	block, err := des.NewTripleDESCipher(key)
	if err != nil {
		return nil, err
	}
	blockMode := cipher.NewCBCEncrypter(block, iv[:block.BlockSize()])
	padded := PKCS7Pad([]byte(plaintext), blockMode.BlockSize())
	ciphertext := make([]byte, len(padded))
	blockMode.CryptBlocks(ciphertext, padded)
	return ciphertext, nil
}

// TODO: This could definitely be cleaner..
func PKCS7Pad(bytes []byte, alignAt int) []byte {
	//The PKCS #7 padding string consists of a sequence of bytes, each of which is equal to the total number of padding bytes added.
	var padding []byte
	//padLen := alignAt - len(bytes)
	padLen := alignAt - (len(bytes) % alignAt)
	switch padLen {
	case 0:
		padding = []byte("")
	case 1:
		padding = []byte("\x01")
	case 2:
		padding = []byte("\x02\x02")
	case 3:
		padding = []byte("\x03\x03\x03")
	case 4:
		padding = []byte("\x04\x04\x04\x04")
	case 5:
		padding = []byte("\x05\x05\x05\x05\x05")
	case 6:
		padding = []byte("\x06\x06\x06\x06\x06\x06")
	case 7:
		padding = []byte("\x07\x07\x07\x07\x07\x07\x07")
	default:
		log.Fatalf("PKCS7Pad unhandled: %v", padLen)
	}

	var paddedBytes []byte
	paddedBytes = append(paddedBytes, bytes...)
	paddedBytes = append(paddedBytes, padding...)

	return paddedBytes
}

func EncryptionKey() []byte {
	//var sb strings.Builder
	//for index := 0; index < 24; index++ {
	//	// (.NET) stringBuilder.Append(char.ConvertFromUtf32(index % 2 == 0 ? index : index * 2));
	//}
	//return sb.String()

	// This is a static key, originally generated by the above loop, then base64'd
	key, err := base64.StdEncoding.DecodeString("AAICBgQKBg4IEgoWDBoOHhAiEiYUKhYu")
	if err != nil {
		panic(err) // This should never actually happen..
	}
	return key
}

func (c *Client) AccessToken() string {
	return c.MakeAccessToken(time.Now())
}

func (c *Client) MakeAccessToken(time time.Time) string {
	requestTime := time.Format("15:04:05")

	key := EncryptionKey()
	iv := []byte(requestTime)

	ciphertext, err := TripleDesEncrypt([]byte(c.clientID), key, iv)
	if err != nil {
		panic(err)
	}

	return base64.StdEncoding.EncodeToString(ciphertext)
}

func (c *Client) CheckToken(checkTimeS string, checkToken string) {
	RFC339Nano7 := "2006-01-02T15:04:05.9999999Z07:00"

	checkTime, err := time.Parse(RFC339Nano7, checkTimeS)
	if err != nil {
		panic(err)
	}

	ourToken := c.MakeAccessToken(checkTime)

	fmt.Printf("checkTimeS : %s\n", checkTimeS)
	fmt.Printf("checkTime  : %s\n", checkTime.Format(RFC339Nano7))
	fmt.Printf("checkToken : %s\n", checkToken)
	fmt.Printf("ourToken   : %s\n", ourToken)

	if !(ourToken == checkToken) {
		panic("tokens don't match.. fail")
	}
}
